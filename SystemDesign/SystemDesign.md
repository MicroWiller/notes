# 系统设计



## 并发和并行的区别
|            并发            |             并行             |
| :-----------------------: | :-------------------------: |
|         同一时间段         |           同一时刻           |
|    同一实体上的多个事件     |     不同实体上的多个事件      |
| 一台处理器上“同时”处理多个任务 | 多台处理器上同时处理多个任务 |





## 性能优化


### 集群

* 将多台服务器组成集群，使用`负载均衡`（nginx）将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低
* 为了使得大型网站具有`伸缩性`，集群中的 **应用服务器**通常需要保持`无状态`
    1.  应用服务器不能存储用户的会话信息 session


#### 负载均衡
1. 集群中的`应用服务器（节点）`通常被设计成**无状态**，用户可以请求任何一个节点
2. 负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上

##### 负载均衡算法

|     |         轮询         |    加权轮询     |        最少连接         | 加权最少连接 | 随机 |  源地址哈希  |
| :-: | :------------------: | :-------------: | :--------------------: | :---------: | :-: | :---------: |
| 区别 | 轮流发送到每个服务器上 | 服务器的性能差异 | 每个请求的连接时间不一样 |             |     | 实现会话粘滞 |

##### 转发实现


#### 集群下的 Session 管理

|     |     Sticky Session     |         Session Replication         |     Session Server      |
| :-: | :--------------------: | :---------------------------------: | :---------------------: |
| 实现 | 哈希(IP)取模(服务器数量) | 同步：每个服务器都有所有用户的 Session | 单独的服务器存储 Session |
|     |                        |                                     |                         |


### 缓存
缓存能够提高性能的原因如下：
- 缓存数据通常位于`内存等介质`中，这种介质对于读操作特别快；
- 缓存数据可以位于靠近用户的地理位置上；
- 可以将计算结果进行缓存，从而`避免重复计算`。

#### 缓存特征
1. 命中率
2. 最大空间
3. 淘汰策略

    |     |  FIFO（First In First Out）  | LRU（Least Recently Used） | LFU（Least Frequently Used） |
    | :-: | :-------------------------: | :------------------------: | :--------------------------: |
    |     | 先进先出策略，在实时性的场景下 |    最近`最久`未使用策略     |      `最不经常`使用策略       |

#### 缓存技术
位置：
1. 客服端
2. 应用服务器
3. 数据库服务器
4. java内部的缓存：字符串常量池、及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池
5. CPU多级缓存

#### CDN：内容分发网络
利用`更靠近用户的服务器`从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等`静态资源`分发给用户

#### 缓存问题
1. 缓存穿透
2. 缓存雪崩
3. 缓存一致性
    - 要保证缓存一致性需要付出很大的代价
4. 缓存“无底洞”现象

#### 数据分布
1. 传统的哈希分布
2. 顺序分布：将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上
3. 一致性哈希

### 异步
> 某些流程可以`将操作转换为消息`，将消息发送到`消息队列`之后立即返回，之后`这个操作会被异步处理`

#### 消息模型
|     |             点对点              |                  发布/订阅                   |             观察者              |
| :-: | :-----------------------------: | :------------------------------------------: | :-----------------------------: |
| 区别 | 异步？？发送一个消息只能被消费一次 | 异步，多个消费者可以从该频道订阅到这条消息并消费 | 同步，观察者和主题都知道对方的存在 |

> 还有助于 流量削峰 和 应用解耦

***

## 可用性

### 冗余
保证高可用性的主要手段，当某个服务器故障时就请求其他服务器
1. 应用服务器：前提条件是保证应用服务器不具有状态
2. 存储服务器：主从复制
### 监控
###  服务降级





## 进程和线程

<img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/ProcessAndThread.png" style="zoom:67%;" />

[照片来源](https://blog.csdn.net/qq_39823627/article/details/78736650) 

- **进程**：系统分配资源的最小单位

- **线程**：CPU调度的最小单位【共享进程的内存地址空间】

  > - 一个进程下面可以有很多线程
  > - 一个线程可以有上千个协程

  

- **协程**：比线程更轻量级，不是在CPU层面【内核】去调度的，而是交给 在用户空间的程序自己

> 协程和线程的区别：
>
> 1. 不再被内核调度，协程没有线程的上下文切换消耗
> 2. 协程的调度切换是用户(程序员) 手动切换的，又叫用户空间线程
> 3. 具有原子操作性







## Nginx



 [Nginx提升性能](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247493308&idx=1&sn=b6b46d8fefb1f09c1abf6cacc9236147&chksm=fc461b4fcb319259b85092fab8fc04e17872bacd7f7c3cc9a1dd723129132e54b18de415a166&mpshare=1&scene=1&srcid=0826sJp3sEWSAR8CLKcLRanM&sharer_sharetime=1598442668904&sharer_shareid=aa55b5520af7873f02181e7e14a32e3e&key=8c9049d0f83009fe792c7807bad8cda193d72a18edf6b92b3f8d860d1bd934edb1a8e944d930587925e1a73e814bbd9c9c548fc1bc954b6403ae4c17ed111c714345104011d377edd9b6446e3640b5dccaeb09b294d73353cabd4be3fd1075ded6977288d81180117eb33acad733e5d415821936990567ae32c5be056258230b&ascene=1&uin=MTY5ODU1NzUxMA%3D%3D&devicetype=Windows+10+x64&version=62090538&lang=zh_CN&exportkey=A%2FS9yWMpdYVvAdnazJOt8SY%3D&pass_ticket=%2BY80DKefrhbOe4NEi9853WeJ7Mnoj%2FoddJBV4o26PyeoEe1AI4l9RCtzl7N6%2B7sZ&wx_header=0
)	







## 技术演进

[淘宝技术演进](https://www.cnblogs.com/52czm/p/11097156.html
)	



[大型应用架构演进历程](https://mp.weixin.qq.com/s/jtBTv1rsFHDDlyqbaWI-bA) 











## 框架设计的套路



 [接口和抽象类：servlet|servlet容器|web容器](https://www.cnblogs.com/yescode/p/14099868.html)	











## 分布式

[分布式和集群的区别及分布式概述](https://www.cnblogs.com/siyuanwai/p/14143554.html) 



[CAP(Consistency、Availability、Partition tolerance)](https://mp.weixin.qq.com/s/X_UxMRCfSGmX9xfj_l6FlQ) : 分布式系统，**当发生分区错误时**，如何选择一致性和可用性。





**副本**是分布式系统解决高可用的唯一手段，也就是主从模式



**热点数据**分为*读* 和*写* 两种情况：

- 读热点很好解决，加一个缓存就能抗住
- 写热点就是做分库分表，当分库分表的规则就要立足于具体的业务场景
- 读操作：缓存和限流是任何时刻都需要做的，不分场景。；写操作：对于单一热点品类的数据存储写入问题，要做到有能力承载



分片有Hash / 一致性hash / 范围分片(可以加入业务属性)等；

Hash 是做分片的一种方式，分片是应对写热点的一种策略；但具体哪个分片规则更合适，要站在业务场景来分析。







**共识算法**是一致性的方案，**强一致性**是共识的状态





一致性 写大多数副本，性能会变慢；一致性和时延，总有一个在路上





## 数据库扩容

[分库分表以后，如何实现扩容？？](https://kaiwu.lagou.com/course/courseInfo.htm?courseId=69#/detail/pc?id=1924)：

1. 对主键进行哈希取模

   - 数据拆分比较均匀，但不利于后续的扩容

2. 基于数据范围进行路由

   - 扩容可以直接增加新的存储，将新生成的数据区间映射到新添加的存储节点中，不需要进行节点之间的调整，也不需要迁移历史数据
   - 缺点就是数据访问不均匀，出现数据库访问瓶颈

3. 结合哈希和数据范围的分库分表规则

   - 先对订单 ID 进行哈希取模，然后对取模后的数据再次进行范围分区

     ![](https://raw.githubusercontent.com/MicroWiller/photobed/master/DatabaeMigration.png)

   - 哈希取模结合数据区间的方式，可以比较好地平衡两种路由方案的优缺点

   - 避免了单纯基于数据范围可能出现的热点存储

   - 后期扩展时，可以直接增加对应的`扩展表`，避免了复杂的数据迁移工作







## 系统边界



- 一个中高级研发工程师对系统的驾驭边界至少是**模块**或者**子系统**层面；

- 一个架构师对系统的驾驭边界至少是**全系统层面**；

- 一个高级架构师对系统的驾驭边界至少是**某一领域**层面。



管理者是通过制度来管理员工之间的协作，架构师是通过技术来管理系统之间的协作





### 架构设计方案



#### 复杂来源

<img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/ComplexOfSystem.png" style="zoom:67%;" />







#### 解决方案

1. 设计两到三套备选方案，考虑通过不同的技术方式来解决问题。
2. 方案设计不用过于详细，而是要确定技术的可行性和优缺点。



#### 评估标准



​		通用的设计原则：设计松耦合、系统可监控、系统无单点、系统可降级、可水平扩展



​		全局性关注点，比如性能、可用性、IT 成本、投入资源、实现复杂度、安全性、后续扩展性等



​	

扩充：系统可降级常用手段主要有三种

1. 限流，即抛弃超出预估流量外的用户。

2. 降级，即抛弃部分不重要的功能，让系统提供有损服务，如商品详情页不展示宝贝收藏的数量，以确保核心功能不受影响。

3. 熔断，即抛弃对故障系统的调用。一般情况下熔断会伴随着降级处理，比如展示兜底数据。



方案没有优劣之分，而是要看哪个更适合当下的问题，只要架构**满足一定时期内的业务发展**就可以



#### 技术实现



需要进一步说明技术上的落地实现方式和深层原理，如果你最终选择基于 Redis 来实现消息队列，那么可以有几种实现方式？各自的优缺点有哪些？对于这些问题，要做到心里有数。



比如: 

- 基于 Redis List 的 LPUSH 和 RPOP 的实现方式
- 基于 Redis 的订阅或发布模式
- 基于 Redis 的有序集合（Sorted Set）的实现方式









